<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[simoneb's blog]]></title>
  <link href="http://simoneb.github.com/atom.xml" rel="self"/>
  <link href="http://simoneb.github.com/"/>
  <updated>2013-04-21T00:34:52+02:00</updated>
  <id>http://simoneb.github.com/</id>
  <author>
    <name><![CDATA[Simone Busoli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Labeling Trees - Exercise 2]]></title>
    <link href="http://simoneb.github.com/blog/2013/04/13/labeling-trees-exercise-2/"/>
    <updated>2013-04-13T01:28:00+02:00</updated>
    <id>http://simoneb.github.com/blog/2013/04/13/labeling-trees-exercise-2</id>
    <content type="html"><![CDATA[<p>In the <a href="http://simoneb.github.com/blog/2013/04/07/labeling-trees-exercise-1">previous post</a> of this series we did a small improvement to the state monad implementation by generalizing it over the type of the state.
This is not exactly a requirement for labeling trees as the state can be simply an integer, but it&#8217;s a more natural choice now that we tackle the second exercise.</p>

<blockquote><p>Go from labeling a tree to doing a constrained
container computation, as in WPF. Give everything a
bounding box, and size subtrees to fit inside their
parents, recursively.</p></blockquote>

<p>As you know the exercises come without any solution, so let&#8217;s try to understand what we need to do here.
Because we&#8217;re talking about binary trees let&#8217;s assume that the requirement is to perform the constrained container computation based on containers with two children,
where each child can either be another container or a terminal element, like a text block.</p>

<p>By translating it to WPF as suggested in the assignment we can represent a branch as a <code>Grid</code> with two rows and a single column.
Each row&#8217;s unique cell can contain either another grid with the same characteristics or a <code>TextBlock</code>.
The layout features of a grid match exactly the solution to the problem we&#8217;re asked to solve, as child elements of grid cells expand to match the size of their parent.</p>

<p>Starting with the same simple tree we used as a sample throughout the series:</p>

<figure class='code'><figcaption><span>A simple tree  (a-simple-tree.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/a-simple-tree.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>                                <span class="c1">//  tree.Show() outputs:</span>
</span><span class='line'><span class="kt">var</span> <span class="n">tree</span> <span class="p">=</span> <span class="n">branch</span><span class="p">(</span>              <span class="c1">//  Branch:</span>
</span><span class='line'>            <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span>          <span class="c1">//    Leaf: a</span>
</span><span class='line'>            <span class="n">branch</span><span class="p">(</span>             <span class="c1">//    Branch:</span>
</span><span class='line'>              <span class="n">branch</span><span class="p">(</span>           <span class="c1">//      Branch:</span>
</span><span class='line'>                <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">),</span>      <span class="c1">//        Leaf: b</span>
</span><span class='line'>                <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">)),</span>     <span class="c1">//        Leaf: c</span>
</span><span class='line'>              <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">)));</span>      <span class="c1">//      Leaf: d</span>
</span><span class='line'>
</span><span class='line'><span class="n">tree</span><span class="p">.</span><span class="n">Show</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>we can transform it into this simple WPF markup, as described earlier:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;Grid&gt;</span>
</span><span class='line'>    <span class="nt">&lt;Grid.RowDefinitions&gt;</span>
</span><span class='line'>        <span class="nt">&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span>
</span><span class='line'>        <span class="nt">&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/Grid.RowDefinitions&gt;</span>
</span><span class='line'>    <span class="nt">&lt;TextBlock</span> <span class="na">Grid.Row=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>a<span class="nt">&lt;/TextBlock&gt;</span>
</span><span class='line'>    <span class="nt">&lt;Grid</span> <span class="na">Grid.Row=</span><span class="s">&quot;1&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;Grid.RowDefinitions&gt;</span>
</span><span class='line'>            <span class="nt">&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span>
</span><span class='line'>            <span class="nt">&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/Grid.RowDefinitions&gt;</span>
</span><span class='line'>        <span class="nt">&lt;Grid</span> <span class="na">Grid.Row=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;Grid.RowDefinitions&gt;</span>
</span><span class='line'>                <span class="nt">&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span>
</span><span class='line'>                <span class="nt">&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/Grid.RowDefinitions&gt;</span>
</span><span class='line'>            <span class="nt">&lt;TextBlock</span> <span class="na">Grid.Row=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>b<span class="nt">&lt;/TextBlock&gt;</span>
</span><span class='line'>            <span class="nt">&lt;TextBlock</span> <span class="na">Grid.Row=</span><span class="s">&quot;1&quot;</span><span class="nt">&gt;</span>c<span class="nt">&lt;/TextBlock&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/Grid&gt;</span>
</span><span class='line'>        <span class="nt">&lt;TextBlock</span> <span class="na">Grid.Row=</span><span class="s">&quot;1&quot;</span><span class="nt">&gt;</span>d<span class="nt">&lt;/TextBlock&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/Grid&gt;</span>
</span><span class='line'><span class="nt">&lt;/Grid&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The result of this markup, along with some additional styling and a bit of logic to outline the bounds of each cell and display its box size, is shown below.
The full code of this example is available as a ready-to-run LINQPad query <a href="http://share.linqpad.net/f2d3sg.linq">here</a>.</p>

<p><img class="center" src="http://simoneb.github.com/images/posts/wpf_grid.png" title="WPF grid sample" ></p>

<p>As you can see the children of grid cells automatically expand to fit their parent&#8217;s size.
More precisely, each grid row gets 50% of the height of its parent, regardless of the contents.
We&#8217;ll now try to do the same monadically by adapting our data structures and labeling logic to this new case.</p>

<p>First of all we need to decide what is the type of the state we&#8217;ll be carrying around.
Intuitively, each time we branch a grid into its two rows we allocate 50% of the available height to each of them, therefore the state will certainly include the available height.
Although not strictly needed in this scenario let&#8217;s make it a little more realistic by including the width as well, and we&#8217;ll call a structure containing two such values a <code>Box</code>.
With this little piece of information we can already define the signature of our function which, similarly to the previous <code>MLabel</code>, will represent the entry point for the constrained box computation.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">Tree</span><span class="p">&lt;</span><span class="n">StateContent</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">MConstrainedBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Box</span> <span class="n">box</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The function takes a tree, which in this case we can imagine being a visual tree of graphic elements, and an initial box size (our initial state), representing the size of the root element.
The return value is a tree whose generic argument is a tuple of state-content values.
The state is the <code>Box</code> representing the size allocated to that tree and the value is the generic parameter <code>T</code> that we&#8217;re currently filling with characters to distinguish a leaf from another leaf.</p>

<p>As we did with the labeling problem the entry function will finally delegate to a helper function that will call itself recursively. We can thus define the body of the previous function as follows:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">Tree</span><span class="p">&lt;</span><span class="n">StateContent</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">MConstrainedBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Box</span> <span class="n">box</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">MConstrainedBox1</span><span class="p">(</span><span class="n">tree</span><span class="p">).</span><span class="n">RunWithState</span><span class="p">(</span><span class="n">box</span><span class="p">).</span><span class="n">Item2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>No big surprises here as the juice is actually in the body of the <code>MConstrainedBox1</code> function, in the same way as it previously was in <code>MLabel1</code>. Let&#8217;s start by defining its signature, which we can infer from above.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">S</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">StateContent</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;&gt;&gt;</span> <span class="n">MConstrainedBox1</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Not much else to do except reasoning about how to solve the problem of assigning box sizes to tree leaves according to the rules described earlier. The process is overall simple, let&#8217;s outline the steps.</p>

<p>If the current tree is a <em>leaf</em> then extract the state value using a proper <code>getState</code> function similar to what we used in the labeling scenario. The main difference here is that when we encounter leaves we do not need to update any state but only extract it from the monad and attach it to the new leaf we create.</p>

<p>If the current tree is a <em>branch</em> then:</p>

<ol>
<li>update the state by halving the height of the current box</li>
<li>recurse over the left branch</li>
<li>recurse over the right branch</li>
<li>update the state by doubling the height of the current box</li>
<li>return an instance of the state monad whose value is a branch with the results of steps 2 and 3 as the left and right trees, respectively</li>
</ol>


<p>Let&#8217;s go through a simple example to understand better.
Assuming to start with a box of size 200 x 400 (W x H) and that the root element of the tree we want to process is a branch,
we halve the available height and process the left and right trees using 200 as the available height for each of them.
If at some point we come across a leaf we use whatever current value of the state we have at that point during the computation
(if both left and right trees are leaves then each of them will get a height of 200). When we&#8217;re done with the two trees we restore the original height by multiplying it by two.
This leads exactly to the solution we&#8217;re looking for.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">StateContent</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;&gt;&gt;</span> <span class="n">MConstrainedBox1</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">tree</span> <span class="k">is</span> <span class="n">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">var</span> <span class="n">lf</span> <span class="p">=</span> <span class="n">tree</span> <span class="k">as</span> <span class="n">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">var</span> <span class="n">getState</span> <span class="p">=</span> <span class="k">new</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">Box</span><span class="p">&gt;</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">RunWithState</span> <span class="p">=</span> <span class="n">b0</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="n">b0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">getState</span><span class="p">,</span> <span class="n">b0</span> <span class="p">=&gt;</span>
</span><span class='line'>                    <span class="n">Return</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">StateContent</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;&gt;&gt;(</span><span class="n">leaf</span><span class="p">(</span><span class="n">stateContent</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">))));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">var</span> <span class="n">br</span> <span class="p">=</span> <span class="n">tree</span> <span class="k">as</span> <span class="n">Branch</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">var</span> <span class="n">halveHeight</span> <span class="p">=</span> <span class="k">new</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">Box</span><span class="p">&gt;</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">RunWithState</span> <span class="p">=</span> <span class="n">b0</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="k">new</span> <span class="n">Box</span><span class="p">(</span><span class="n">b0</span><span class="p">.</span><span class="n">Width</span><span class="p">,</span> <span class="n">b0</span><span class="p">.</span><span class="n">Height</span><span class="p">/</span><span class="m">2</span><span class="p">),</span> <span class="n">b0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">var</span> <span class="n">doubleHeight</span> <span class="p">=</span> <span class="k">new</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">Box</span><span class="p">&gt;</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">RunWithState</span> <span class="p">=</span> <span class="n">b0</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="k">new</span> <span class="n">Box</span><span class="p">(</span><span class="n">b0</span><span class="p">.</span><span class="n">Width</span><span class="p">,</span> <span class="n">b0</span><span class="p">.</span><span class="n">Height</span><span class="p">*</span><span class="m">2</span><span class="p">),</span> <span class="n">b0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">halveHeight</span><span class="p">,</span> <span class="n">_</span> <span class="p">=&gt;</span> <span class="n">Bind</span><span class="p">(</span><span class="n">MConstrainedBox1</span><span class="p">(</span><span class="n">br</span><span class="p">.</span><span class="n">Left</span><span class="p">),</span>
</span><span class='line'>                    <span class="n">left</span> <span class="p">=&gt;</span> <span class="n">Bind</span><span class="p">(</span><span class="n">MConstrainedBox1</span><span class="p">(</span><span class="n">br</span><span class="p">.</span><span class="n">Right</span><span class="p">),</span>
</span><span class='line'>                    <span class="n">right</span> <span class="p">=&gt;</span> <span class="n">Bind</span><span class="p">(</span><span class="n">doubleHeight</span><span class="p">,</span>  <span class="n">__</span> <span class="p">=&gt;</span>
</span><span class='line'>                    <span class="n">Return</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">StateContent</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;&gt;&gt;(</span><span class="n">branch</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))))));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now if we run the computation against the same old tree:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">tree</span> <span class="p">=</span> <span class="n">branch</span><span class="p">(</span>
</span><span class='line'>               <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span>
</span><span class='line'>               <span class="n">branch</span><span class="p">(</span>
</span><span class='line'>                   <span class="n">branch</span><span class="p">(</span>
</span><span class='line'>                       <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">),</span>
</span><span class='line'>                       <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">)),</span>
</span><span class='line'>                   <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'><span class="n">MConstrainedBox</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="k">new</span> <span class="n">Box</span><span class="p">(</span><span class="m">200</span><span class="p">,</span> <span class="m">400</span><span class="p">)).</span><span class="n">Show</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>the result we obtain is the same we obtained using WPF:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">Branch</span><span class="p">:</span>
</span><span class='line'>  <span class="n">Leaf</span><span class="p">:</span> <span class="p">{</span> <span class="n">State</span> <span class="p">=</span> <span class="p">{</span> <span class="n">Width</span> <span class="p">=</span> <span class="m">200</span><span class="p">,</span> <span class="n">Height</span> <span class="p">=</span> <span class="m">200</span> <span class="p">},</span> <span class="n">Value</span> <span class="p">=</span> <span class="n">a</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">Branch</span><span class="p">:</span>
</span><span class='line'>    <span class="n">Branch</span><span class="p">:</span>
</span><span class='line'>      <span class="n">Leaf</span><span class="p">:</span> <span class="p">{</span> <span class="n">State</span> <span class="p">=</span> <span class="p">{</span> <span class="n">Width</span> <span class="p">=</span> <span class="m">200</span><span class="p">,</span> <span class="n">Height</span> <span class="p">=</span> <span class="m">50</span> <span class="p">},</span> <span class="n">Value</span> <span class="p">=</span> <span class="n">b</span> <span class="p">}</span>
</span><span class='line'>      <span class="n">Leaf</span><span class="p">:</span> <span class="p">{</span> <span class="n">State</span> <span class="p">=</span> <span class="p">{</span> <span class="n">Width</span> <span class="p">=</span> <span class="m">200</span><span class="p">,</span> <span class="n">Height</span> <span class="p">=</span> <span class="m">50</span> <span class="p">},</span> <span class="n">Value</span> <span class="p">=</span> <span class="n">c</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">Leaf</span><span class="p">:</span> <span class="p">{</span> <span class="n">State</span> <span class="p">=</span> <span class="p">{</span> <span class="n">Width</span> <span class="p">=</span> <span class="m">200</span><span class="p">,</span> <span class="n">Height</span> <span class="p">=</span> <span class="m">100</span> <span class="p">},</span> <span class="n">Value</span> <span class="p">=</span> <span class="n">d</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <a href="https://gist.github.com/simoneb/5332234/51fcfafaa8bf911d70cb50978d06a29d8e1492db">full source code</a> is as usual available as gist containing a LINQPad query that you can download an run right away.<br/>
In the next post we&#8217;ll do a step forward in defining a self-contained monad type before moving on to more interesting and challenging exercises.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Labeling Trees - Exercise 1]]></title>
    <link href="http://simoneb.github.com/blog/2013/04/07/labeling-trees-exercise-1/"/>
    <updated>2013-04-07T19:41:00+02:00</updated>
    <id>http://simoneb.github.com/blog/2013/04/07/labeling-trees-exercise-1</id>
    <content type="html"><![CDATA[<p>In the <a href="http://simoneb.github.com/blog/2013/03/31/labeling-trees-invisible-state">last post</a> of this series we learned how to label a binary tree monadically, and in doing so we discovered the state monad. I&#8217;ve collected the pieces we built incrementally last time into <a href="https://gist.github.com/simoneb/5332234/7beedb523a5c8ed2c72142000c881b3b3a890703">this gist</a> containing the whole monadic label implementation as a <a href="http://www.linqpad.net">LINQPad</a> query that you can simply copy and run. I&#8217;ll keep making changes to that gist and create links which point to specific revisions from now on.</p>

<p>As I mentioned in the <a href="http://simoneb.github.com/blog/2013/03/17/labeling-trees-introduction">introduction</a> I decided to write this series as a result of watching some years ago Brian Beckman talking about monads and not being able to grasp the topic at that time. Going through it again and explaining what it took me to understand it will hopefully help someone else follow the same path. Up until now we&#8217;ve rediscovered what Brian explained in his interviews, but the accompanying source code (that I&#8217;ve copied in <a href="https://gist.github.com/simoneb/627a349a1632307c301b">this gist</a> for convenience) also gave 10 assignments to the reader - without solutions - which I&#8217;m going to tackle in the remainder of this series.</p>

<p>The exercises are of varying difficulties, basically expanding on the topic of the state monad with tasks which require generalizing the pattern and applying it to solve problems other than labeling binary trees. So, without further ado, let&#8217;s move on to the first exercise.</p>

<h3>Exercise 1</h3>

<blockquote><p>generalize over the type of the state, from int
to &lt;TState>, say, so that the S type can handle any kind of
state object. Start with Labeled&lt;T> &#8211;> StateContent&lt;TState, T>, from
&#8220;label-content pair&#8221; to &#8220;state-content pair&#8221;.</p></blockquote>

<p>I rephrased the original text of the exercise a little bit so it matches our own implementation rather than Brian&#8217;s. Some type names are different as well as some design choices, but the overall concept is the same. Let&#8217;s see what this exercise is about.</p>

<p>So far we used a <code>Labeled&lt;T&gt;</code> class to represent the contents of a labeled tree - leaves, specifically. This class is a simple container of label and value pairs, where only the latter is generically parameterized via the <code>T</code> generic parameter. This exercise requires to parameterize the type of the label/state too, which is currently fixed to be an integer.  It doesn&#8217;t sound very difficult, does it? We simply come up with a new type <code>StateContent&lt;TState, T&gt;</code> which does just that, and then adapt the usages of <code>Labeled&lt;T&gt;</code> to match the new type.</p>

<p>In addition to that we&#8217;ll also have to make some changes to the <code>S&lt;T&gt;</code> class, because it&#8217;s hardcoding the type of the state to be an integer. This will in turn require some changes to the <code>MLabel1</code> function, mainly to cope with limited type inference capabilities of the C# compiler. The end result is shown in the diff below.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'><span class="gu">@@ -59,10 +59,10 @@ public class Branch&lt;T&gt; : Tree&lt;T&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="gd">-public class Labeled&lt;T&gt;</span>
</span><span class='line'><span class="gi">+public class StateContent&lt;TState, T&gt;</span>
</span><span class='line'> {
</span><span class='line'><span class="gd">-    public int Label { get; private set; }</span>
</span><span class='line'><span class="gi">+    public TState State { get; private set; }</span>
</span><span class='line'>     public T Value { get; private set; }
</span><span class='line'>
</span><span class='line'><span class="gd">-    public Labeled(int label, T value)</span>
</span><span class='line'><span class="gi">+    public StateContent(TState state, T value)</span>
</span><span class='line'>     {
</span><span class='line'><span class="gd">-        Label = label;</span>
</span><span class='line'><span class="gi">+        State = state;</span>
</span><span class='line'>         Value = value;
</span><span class='line'><span class="gu">@@ -72,3 +72,3 @@ public class Labeled&lt;T&gt;</span>
</span><span class='line'>     {
</span><span class='line'><span class="gd">-        return new { Label, Value }.ToString();</span>
</span><span class='line'><span class="gi">+        return new { State, Value }.ToString();</span>
</span><span class='line'>     }
</span><span class='line'><span class="gu">@@ -86,15 +86,15 @@ public Tree&lt;T&gt; branch&lt;T&gt;(Tree&lt;T&gt; left, Tree&lt;T&gt; right)</span>
</span><span class='line'>
</span><span class='line'><span class="gd">-public Labeled&lt;T&gt; labeled&lt;T&gt;(int label, T value)</span>
</span><span class='line'><span class="gi">+public StateContent&lt;TState, T&gt; stateContent&lt;TState, T&gt;(TState state, T value)</span>
</span><span class='line'> {
</span><span class='line'><span class="gd">-    return new Labeled&lt;T&gt;(label, value);</span>
</span><span class='line'><span class="gi">+    return new StateContent&lt;TState, T&gt;(state, value);</span>
</span><span class='line'> }
</span><span class='line'>
</span><span class='line'><span class="gd">-public class S&lt;T&gt;</span>
</span><span class='line'><span class="gi">+public class S&lt;TState, T&gt;</span>
</span><span class='line'> {
</span><span class='line'><span class="gd">-    public Func&lt;int, Tuple&lt;int, T&gt;&gt; RunWithState;</span>
</span><span class='line'><span class="gi">+    public Func&lt;TState, Tuple&lt;TState, T&gt;&gt; RunWithState;</span>
</span><span class='line'> }
</span><span class='line'>
</span><span class='line'><span class="gd">-public static S&lt;U&gt; Bind&lt;T, U&gt;(S&lt;T&gt; m, Func&lt;T, S&lt;U&gt;&gt; k)</span>
</span><span class='line'><span class="gi">+public static S&lt;TState, U&gt; Bind&lt;TState, T, U&gt;(S&lt;TState, T&gt; m, Func&lt;T, S&lt;TState, U&gt;&gt; k)</span>
</span><span class='line'> {
</span><span class='line'><span class="gd">-    return new S&lt;U&gt; </span>
</span><span class='line'><span class="gi">+    return new S&lt;TState, U&gt; </span>
</span><span class='line'>     {
</span><span class='line'><span class="gu">@@ -102,3 +102,3 @@ public static S&lt;U&gt; Bind&lt;T, U&gt;(S&lt;T&gt; m, Func&lt;T, S&lt;U&gt;&gt; k)</span>
</span><span class='line'>         {
</span><span class='line'><span class="gd">-            Tuple&lt;int, T&gt; mResult = m.RunWithState(s0);</span>
</span><span class='line'><span class="gi">+            Tuple&lt;TState, T&gt; mResult = m.RunWithState(s0);</span>
</span><span class='line'>
</span><span class='line'><span class="gu">@@ -109,5 +109,5 @@ public static S&lt;U&gt; Bind&lt;T, U&gt;(S&lt;T&gt; m, Func&lt;T, S&lt;U&gt;&gt; k)</span>
</span><span class='line'>
</span><span class='line'><span class="gd">-public static S&lt;T&gt; Return&lt;T&gt;(T value)</span>
</span><span class='line'><span class="gi">+public static S&lt;TState, T&gt; Return&lt;TState, T&gt;(T value)</span>
</span><span class='line'> {
</span><span class='line'><span class="gd">-    return new S&lt;T&gt; </span>
</span><span class='line'><span class="gi">+    return new S&lt;TState, T&gt; </span>
</span><span class='line'>     {
</span><span class='line'><span class="gu">@@ -117,3 +117,3 @@ public static S&lt;T&gt; Return&lt;T&gt;(T value)</span>
</span><span class='line'>
</span><span class='line'><span class="gd">-public Tree&lt;Labeled&lt;T&gt;&gt; MLabel&lt;T&gt;(Tree&lt;T&gt; tree)</span>
</span><span class='line'><span class="gi">+public Tree&lt;StateContent&lt;int, T&gt;&gt; MLabel&lt;T&gt;(Tree&lt;T&gt; tree)</span>
</span><span class='line'> {
</span><span class='line'><span class="gu">@@ -122,3 +122,3 @@ public Tree&lt;Labeled&lt;T&gt;&gt; MLabel&lt;T&gt;(Tree&lt;T&gt; tree)</span>
</span><span class='line'>
</span><span class='line'><span class="gd">-public S&lt;Tree&lt;Labeled&lt;T&gt;&gt;&gt; MLabel1&lt;T&gt;(Tree&lt;T&gt; tree)</span>
</span><span class='line'><span class="gi">+public S&lt;int, Tree&lt;StateContent&lt;int, T&gt;&gt;&gt; MLabel1&lt;T&gt;(Tree&lt;T&gt; tree)</span>
</span><span class='line'> {
</span><span class='line'><span class="gu">@@ -128,3 +128,3 @@ public S&lt;Tree&lt;Labeled&lt;T&gt;&gt;&gt; MLabel1&lt;T&gt;(Tree&lt;T&gt; tree)</span>
</span><span class='line'>
</span><span class='line'><span class="gd">-        var updateState = new S&lt;int&gt; </span>
</span><span class='line'><span class="gi">+        var updateState = new S&lt;int, int&gt; </span>
</span><span class='line'>         {
</span><span class='line'><span class="gu">@@ -134,3 +134,3 @@ public S&lt;Tree&lt;Labeled&lt;T&gt;&gt;&gt; MLabel1&lt;T&gt;(Tree&lt;T&gt; tree)</span>
</span><span class='line'>         return Bind(updateState,
</span><span class='line'><span class="gd">-                    label =&gt; Return(leaf(labeled(label, lf.Value))));</span>
</span><span class='line'><span class="gi">+                    label =&gt; Return&lt;int, Tree&lt;StateContent&lt;int, T&gt;&gt;&gt;(leaf(stateContent(label, lf.Value))));</span>
</span><span class='line'>     }
</span><span class='line'><span class="gu">@@ -142,3 +142,3 @@ public S&lt;Tree&lt;Labeled&lt;T&gt;&gt;&gt; MLabel1&lt;T&gt;(Tree&lt;T&gt; tree)</span>
</span><span class='line'>                     left =&gt; Bind(MLabel1(br.Right),
</span><span class='line'><span class="gd">-                                 right =&gt; Return(branch(left, right))));</span>
</span><span class='line'><span class="gi">+                                 right =&gt; Return&lt;int, Tree&lt;StateContent&lt;int, T&gt;&gt;&gt;(branch(left, right))));</span>
</span><span class='line'>     }
</span></code></pre></td></tr></table></div></figure>


<p>It was an easy one this time, which sets the foundation for the next exercise, but we&#8217;ll come to it in the next post. The source code after this change is in the same old gist at <a href="https://gist.github.com/simoneb/5332234/b8e4d6afc501ff4dd74de6b9e7e8c2d5548e81b4">this revision</a>.</p>

<p>Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Labeling Trees - Invisible state]]></title>
    <link href="http://simoneb.github.com/blog/2013/03/31/labeling-trees-invisible-state/"/>
    <updated>2013-03-31T01:45:00+01:00</updated>
    <id>http://simoneb.github.com/blog/2013/03/31/labeling-trees-invisible-state</id>
    <content type="html"><![CDATA[<p>This is the second post of a series about labeling trees. In the <a href="http://simoneb.github.com/blog/2013/03/17/labeling-trees-introduction">previous post</a> we saw how to mark leaves of a binary tree with integer, incrementing labels, first manually and then functionally without relying on mutable state. We achieved it by writing a recursive <code>Label1</code> function which threaded the value of the label, the <em>state</em>, via function arguments and return value, incrementing it every time it came across a leaf of the tree.</p>

<p>Let&#8217;s review the signature of the <code>Label1</code> function and then move one step forward towards a different, less explicit way to pass the state around.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;</span> <span class="n">Label1</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">int</span> <span class="n">label</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>As the signature clearly shows the state passing is visible both in the arguments and the return value of the function. There is certainly a good reason for that: if we need to increment the label and use the new value whenever we come across the next leaf would it be possible to do otherwise? Let&#8217;s as well review the part of the function which took care of applying labels to the leaves.</p>

<figure class='code'><figcaption><span>Label1 leaf logic  (label1-leaves.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/label1-leaves.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">lf</span> <span class="p">=</span> <span class="n">tree</span> <span class="k">as</span> <span class="n">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;;</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">label</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>This simple code mixes together two concerns: creating a labeled leaf and incrementing the value of the label, squeezing them into a tuple. Let&#8217;s try to abstract and extract these two responsibilities and then apply a series of simple transformations over them, while keeping the behavior unchanged.</p>

<h4>First transformation: from integer to tuple</h4>

<figure class='code'><figcaption><span>Label1 first transformation  (label1-leaves-transformation-1.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/label1-leaves-transformation-1.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">// previous:    int</span>
</span><span class='line'><span class="c1">// current:     Tuple&lt;int, int&gt;</span>
</span><span class='line'><span class="kt">var</span> <span class="n">newAndOldLabel</span> <span class="p">=</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">label</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">newAndOldLabel</span><span class="p">.</span><span class="n">Item1</span><span class="p">,</span> <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="n">newAndOldLabel</span><span class="p">.</span><span class="n">Item2</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here we extracted the increment concern as a standalone operation. <code>newAndOldLabel</code> is a tuple whose first item contains the new value of the label and the second item contains the previous, unchanged value. The second statement simply uses it to create the final tuple.</p>

<h4>Second transformation: from tuple to functions returning tuples</h4>

<figure class='code'><figcaption><span>Label1 second transformation  (label1-leaves-transformation-2.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/label1-leaves-transformation-2.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">// previous:    Tuple&lt;int, Tree&lt;Labeled&lt;T&gt;&gt;&gt;</span>
</span><span class='line'><span class="c1">// current:     Tuple&lt;int, int&gt; =&gt; Tuple&lt;int, Tree&lt;Labeled&lt;T&gt;&gt;&gt;</span>
</span><span class='line'><span class="n">Func</span><span class="p">&lt;</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;&gt;</span> <span class="n">labelLeaf</span> <span class="p">=</span>
</span><span class='line'>    <span class="n">arguments</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">arguments</span><span class="p">.</span><span class="n">Item1</span><span class="p">,</span> <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="n">arguments</span><span class="p">.</span><span class="n">Item2</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="nf">labelLeaf</span><span class="p">(</span><span class="n">newAndOldLabel</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here we wrap the last statement from the previous step into a function which accesses <code>newAndOldLabel</code> via its arguments (rather than via local variables) and returns the result of invoking the function itself with <code>newAndOldLabel</code>.</p>

<h4>Third transformation: from anything to functions</h4>

<figure class='code'><figcaption><span>Label1 third transformation  (label1-leaves-transformation-3.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/label1-leaves-transformation-3.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">// previous:    Tuple&lt;int, int&gt;</span>
</span><span class='line'><span class="c1">// current:     int =&gt; Tuple&lt;int, int&gt;</span>
</span><span class='line'><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;&gt;</span> <span class="n">bumpLabel</span> <span class="p">=</span> <span class="n">s</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">s</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// previous:    Tuple&lt;int, int&gt; =&gt; Tuple&lt;int, Tree&lt;Labeled&lt;T&gt;&gt;&gt;</span>
</span><span class='line'><span class="c1">// current:     int =&gt; int =&gt; Tuple&lt;int, Tree&lt;Labeled&lt;T&gt;&gt;&gt;</span>
</span><span class='line'><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;&gt;&gt;</span> <span class="n">labelLeafCurried</span> <span class="p">=</span>
</span><span class='line'>    <span class="n">labelValue</span> <span class="p">=&gt;</span> <span class="n">s</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="n">labelValue</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">bumpResult</span> <span class="p">=</span> <span class="n">bumpLabel</span><span class="p">(</span><span class="n">label</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="nf">labelLeafCurried</span><span class="p">(</span><span class="n">bumpResult</span><span class="p">.</span><span class="n">Item2</span><span class="p">)(</span><span class="n">bumpResult</span><span class="p">.</span><span class="n">Item1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here we apply a transformation to both the label increment and the leaf-labeling logic. In the first case we wrap the creation of the <code>newAndOldLabel</code> tuple into a function which rather than grabbing the value of the label from the integer <code>label</code> argument of the containing function accesses it via its own argument.<br/>
In the second case we <em>curry</em> the already existing function so that instead of accepting a tuple argument it accepts a single integer argument and returns a function which accepts another integer argument and finally returns our output tuple. The external function takes care of fixing the <em>current</em> value used to apply a label to the leaf, while the inner function fixes the <em>new</em>, incremented label value as the first item of the resulting tuple.</p>

<p>The rest of the code <em>binds</em> together these two functions in a way which preserves the overall behavior.</p>

<h4>Fourth transformation: Bind</h4>

<p>As we just mentioned binding, let&#8217;s finally abstract this concept into its own <code>Bind</code> generic function. This function basically encapsulates the logic of composing <code>bumpLabel</code> and <code>labelLeafCurried</code> from the previous transformation.</p>

<figure class='code'><figcaption><span>Label1 fourth transformation  (label1-leaves-transformation-4.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/label1-leaves-transformation-4.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">return</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">bumpLabel</span><span class="p">,</span> <span class="n">labelLeafCurried</span><span class="p">)(</span><span class="n">label</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Before looking at its definition let&#8217;s observe some of the characteristics of this function. It takes two functions as its arguments and returns a third function, which is then executed passing <code>label</code> as its only argument. Knowing both the signatures of the input functions and the return type of the containing <code>Label1</code> function implies that we also know the signature of the <code>Bind</code> function. Furthermore, being a replacement for the last few lines of code from the previous step means that the body will encapsulate the same logic in some form.</p>

<figure class='code'><figcaption><span>Bind  (bind-tuples.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/bind-tuples.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;&gt;</span> <span class="n">Bind</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
</span><span class='line'>    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;&gt;</span> <span class="n">m</span><span class="p">,</span>
</span><span class='line'>    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;&gt;&gt;</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">s0</span> <span class="p">=&gt;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">var</span> <span class="n">mResult</span> <span class="p">=</span> <span class="n">m</span><span class="p">(</span><span class="n">s0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">var</span> <span class="n">kResult</span> <span class="p">=</span> <span class="n">k</span><span class="p">(</span><span class="n">mResult</span><span class="p">.</span><span class="n">Item2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nf">kResult</span><span class="p">(</span><span class="n">mResult</span><span class="p">.</span><span class="n">Item1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The important thing to note is that we&#8217;ve come here by applying some simple and logical transformations to the initial code, and if you try to follow what this code is doing you can realize that the behavior is unchanged. One final step to abstract this even more is to make it generic over the second item of the tuples involved, thus leading to a new signature (the body is unchanged).</p>

<figure class='code'><figcaption><span>Generic Bind  (bind-tuples-generic.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/bind-tuples-generic.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">U</span><span class="p">&gt;&gt;</span> <span class="n">Bind</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">&gt;(</span>
</span><span class='line'>    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">m</span><span class="p">,</span>
</span><span class='line'>    <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">U</span><span class="p">&gt;&gt;&gt;</span> <span class="n">k</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Fifth transformation: S type</h4>

<p>The signature of our <code>Bind</code> function is a mouthful, but we can see that there&#8217;s a recurring pattern in there. Specifically, we can see occurrences of <code>Func&lt;int, Tuple&lt;int, X&gt;&gt;</code> again and again. Let&#8217;s encapsulate this into a generic type <code>S&lt;T&gt;</code> which will have a single member of that function type, arbitrarily named <code>RunWithState</code>.</p>

<figure class='code'><figcaption><span>Empty S<T> class  (s-class-empty.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/s-class-empty.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">S</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">RunWithState</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&#8217;s as well rewrite <code>Bind</code> in terms of <code>S</code>.</p>

<figure class='code'><figcaption><span>Bind  (bind.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/bind.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">Bind</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">&gt;(</span><span class="n">S</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;&gt;</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">RunWithState</span> <span class="p">=</span> <span class="n">s0</span> <span class="p">=&gt;</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">mResult</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="n">RunWithState</span><span class="p">(</span><span class="n">s0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="nf">k</span><span class="p">(</span><span class="n">mResult</span><span class="p">.</span><span class="n">Item2</span><span class="p">).</span><span class="n">RunWithState</span><span class="p">(</span><span class="n">mResult</span><span class="p">.</span><span class="n">Item1</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now we can apply one additional transformation to our <code>Label1</code> function by rewriting everything in terms of <code>S</code>.</p>

<figure class='code'><figcaption><span>Label1 fifth transformation  (label1-leaves-transformation-5.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/label1-leaves-transformation-5.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">bumpLabelS</span> <span class="p">=</span> <span class="k">new</span> <span class="n">S</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">RunWithState</span> <span class="p">=</span> <span class="n">s0</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">s0</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;&gt;</span> <span class="n">labelLeafS</span> <span class="p">=</span> <span class="n">labelValue</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">RunWithState</span> <span class="p">=</span> <span class="n">s1</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="n">labelValue</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">)))</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">bumpLabelS</span><span class="p">,</span> <span class="n">labelLeafS</span><span class="p">).</span><span class="n">RunWithState</span><span class="p">(</span><span class="n">label</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Sixth transformation: Return</h4>

<p>We can finally observe one more pattern in how the <code>labelLeafS</code> function creates an instance of the <code>S</code> type. You can see that the only value this instance depends on is the labeled leaf created inside its <code>RunWithState</code> function, which is of exactly the same type as the generic argument of the instance <code>S&lt;Tree&lt;Labeled&lt;T&gt;&gt;&gt;</code>. Not that we benefit much from it now, but let&#8217;s extract this pattern into a <code>Return</code> method, which given a <code>T</code>, returns an instance of <code>S&lt;T&gt;</code>.</p>

<figure class='code'><figcaption><span>Return  (return.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/return.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Return</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">RunWithState</span> <span class="p">=</span> <span class="n">s</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="k">value</span><span class="p">)</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&#8217;s also rewrite the relevant part of the <code>Label1</code> function in terms of <code>Return</code>, additionally inlining the <code>labelLeafS</code> function.</p>

<figure class='code'><figcaption><span>Label1 sixth transformation  (label1-leaves-transformation-6.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/label1-leaves-transformation-6.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">return</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">bumpLabelS</span><span class="p">,</span>
</span><span class='line'>            <span class="n">labelValue</span> <span class="p">=&gt;</span> <span class="n">Return</span><span class="p">(</span><span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="n">labelValue</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">))))</span>
</span><span class='line'>       <span class="p">.</span><span class="n">RunWithState</span><span class="p">(</span><span class="n">label</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Hiding the state</h3>

<p>Before we move on and formalize the outcome of this long sequence of transformations in a new, named pattern let&#8217;s observe one important thing in the final version of our code. The final statement returns a value of type <code>Tuple&lt;int, Tree&lt;Labeled&lt;T&gt;&gt;&gt;</code> simply because we execute the <code>RunWithState</code> function of the <code>S&lt;Tree&lt;Labeled&lt;T&gt;&gt;&gt;</code> instance returned by <code>Bind</code>.  Executing this function is also the only occasion in which we use the integer <code>label</code> argument of the containing function <code>Label1</code>.</p>

<p>The observation is therefore: if rather than returning a <code>Tuple&lt;int, Tree&lt;Labeled&lt;T&gt;&gt;&gt;</code> we returned <code>S&lt;Tree&lt;Labeled&lt;T&gt;&gt;&gt;</code> then we wouldn&#8217;t need the <code>label</code> argument in <code>Label1</code> and shift to the caller the responsibility of executing <code>RunWithState</code> with the initial label value. In fact <code>Label</code>, the caller, is already doing that, just more explicitly via function arguments, but we can see that we have an opportunity to change the pattern of providing the initial state by moving from a function with this signature:</p>

<figure class='code'><figcaption><span>pseudo old signature</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>To a function with this signature:</p>

<figure class='code'><figcaption><span>pseudo new signature</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">=&gt;</span> <span class="kt">int</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Those familiar with functional programming will find that this is vaguely similar to currying, where a function of n arguments is transformed into n functions of 1 argument each.</p>

<p>We now have all the building blocks for rewriting our whole labeling functions <code>Label</code> and <code>Label1</code> from a completely new perspective, where the final outcome is the same but the means by which we get there are completely different. This also justifies creating two new functions called <code>MLabel</code> and <code>MLabel1</code>, respectively.</p>

<figure class='code'><figcaption><span>MLabel and MLabel1  (mlabel-and-mlabel1.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/mlabel-and-mlabel1.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">MLabel</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">MLabel1</span><span class="p">(</span><span class="n">tree</span><span class="p">).</span><span class="n">RunWithState</span><span class="p">(</span><span class="m">0</span><span class="p">).</span><span class="n">Item2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span> <span class="n">S</span><span class="p">&lt;</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;</span> <span class="n">MLabel1</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">tree</span> <span class="k">is</span> <span class="n">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">var</span> <span class="n">lf</span> <span class="p">=</span> <span class="n">tree</span> <span class="k">as</span> <span class="n">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">var</span> <span class="n">updateState</span> <span class="p">=</span> <span class="k">new</span> <span class="n">S</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">RunWithState</span> <span class="p">=</span> <span class="n">s0</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">s0</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">updateState</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">labelValue</span> <span class="p">=&gt;</span> <span class="n">Return</span><span class="p">(</span><span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="n">labelValue</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">))));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">var</span> <span class="n">br</span> <span class="p">=</span> <span class="n">tree</span> <span class="k">as</span> <span class="n">Branch</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">MLabel1</span><span class="p">(</span><span class="n">br</span><span class="p">.</span><span class="n">Left</span><span class="p">),</span>
</span><span class='line'>                    <span class="n">left</span> <span class="p">=&gt;</span> <span class="n">Bind</span><span class="p">(</span><span class="n">MLabel1</span><span class="p">(</span><span class="n">br</span><span class="p">.</span><span class="n">Right</span><span class="p">),</span>
</span><span class='line'>                                 <span class="n">right</span> <span class="p">=&gt;</span> <span class="n">Return</span><span class="p">(</span><span class="n">branch</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Together with <code>Bind</code>, <code>Return</code> and the type <code>S&lt;T&gt;</code> this is the bulk of the code required to label trees in this new way.</p>

<p>Now, although we have gone to great lengths talking about leaves, you might wonder why branches did not deserve their own considerations as I&#8217;ve included them in the code above already.<br/>
The reason is that as soon as you understand what we did with leaves it should be easy, even easier, to figure out what is happening with branches, as there is no state change involved. Before we try to understand the similarities I suggest you lookup the <a href="http://simoneb.github.com/blog/2013/03/17/labeling-trees-introduction#label">final version of the code</a> from the previous post.</p>

<p>The analogy should be more visible than it is for leaves, let&#8217;s explain in words. We bind a recursive call to <code>MLabel1</code> fed with the left tree of the branch to a function which takes the left labeled tree and binds another recursive call, this time fed with the right tree, to a function which takes the right labeled tree and <em>returns</em> an instance of the <em>state monad</em> created from a branch whose left tree is accessed via a closure and the right is the argument of the function itself.</p>

<p>Besides the mouthful, did I just say <em>state monad</em>? Ah right, the state monad is the triplet represented by <code>S&lt;T&gt;</code>, <code>Bind</code> and <code>Return</code>, while <code>MLabel</code> and <code>MLabel1</code> are just our logic to label a tree in a third way besides manually and functionally: <em>monadically</em>.</p>

<p>As for the state monad, we just invented it, but more on this in the next post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Labeling Trees - Introduction]]></title>
    <link href="http://simoneb.github.com/blog/2013/03/17/labeling-trees-introduction/"/>
    <updated>2013-03-17T00:00:00+01:00</updated>
    <id>http://simoneb.github.com/blog/2013/03/17/labeling-trees-introduction</id>
    <content type="html"><![CDATA[<p>A few years ago I came across a video interview on Channel 9 starring Brian Beckman on a topic which I had never heard of before. The interview is still available online (<a href="http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad">part 1</a> and <a href="http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Stateless-State-The-State-Monad-Part-2">part 2</a>) but you don&#8217;t need to watch it to follow me as I&#8217;ll start from the beginning and guide you gently through the whole topic.</p>

<p>Although I then considered myself an already proficient C# developer I was quite confused, I just couldn&#8217;t wrap my head around the crazy concept of passing state around <em>invisibly</em>, although it was done in my favorite language. The interview comes with full source code and an assignment containing 10 exercises, which I was quite disappointed I could not even tackle. The main topic of the interview is labeling a binary tree, and Brian showed how to do it in several ways, which we&#8217;ll see and try to understand before moving on to the exercises.</p>

<p>Time has passed and I can finally go back to that interesting topic and hopefully help someone else out there. The topic, needless to say, is monads, and not even the simplest of the monads, the state monad. This post is the first of a series where I&#8217;ll introduce the concept and then go through the exercises, hopefully solving them correctly.</p>

<p>Without further ado, here&#8217;s the class which will accompany us throughout the journey, during which it will undergo only minor changes: a binary tree in C#.</p>

<figure class='code'><figcaption><span>A binary tree  (binary-tree.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/binary-tree.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">abstract</span> <span class="k">void</span> <span class="nf">Show</span><span class="p">(</span><span class="kt">int</span> <span class="n">indent</span> <span class="p">=</span> <span class="m">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="nf">Leaf</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Show</span><span class="p">(</span><span class="kt">int</span> <span class="n">indent</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="k">new</span> <span class="kt">string</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="n">indent</span> <span class="p">*</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">&quot;Leaf: &quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">Branch</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Left</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Right</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="nf">Branch</span><span class="p">(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">Left</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Right</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Show</span><span class="p">(</span><span class="kt">int</span> <span class="n">indent</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">new</span> <span class="kt">string</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="n">indent</span> <span class="p">*</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">&quot;Branch:&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">Left</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">indent</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
</span><span class='line'>        <span class="n">Right</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">indent</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you can see a tree can either be a leaf, containing a <code>Value</code>, or a branch, whose left and right sides will be other trees (and thus either branches or leaves). The entire class hierarchy is generic for no special purpose except that it will allow us to give a meaningful representation to the leaves via their <code>T Value</code> property. I&#8217;ve also included a <code>Show(int)</code> method to easily ask the tree to dump itself to the output stream. A couple of helper methods to create branches and leaves will also come useful:</p>

<figure class='code'><figcaption><span>Helper methods to create trees  (helper-methods.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/helper-methods.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">branch</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">Branch</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now creating and displaying a tree of type <code>string</code> is straightforward:</p>

<figure class='code'><figcaption><span>A simple tree  (a-simple-tree.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/a-simple-tree.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>                                <span class="c1">//  tree.Show() outputs:</span>
</span><span class='line'><span class="kt">var</span> <span class="n">tree</span> <span class="p">=</span> <span class="n">branch</span><span class="p">(</span>              <span class="c1">//  Branch:</span>
</span><span class='line'>            <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span>          <span class="c1">//    Leaf: a</span>
</span><span class='line'>            <span class="n">branch</span><span class="p">(</span>             <span class="c1">//    Branch:</span>
</span><span class='line'>              <span class="n">branch</span><span class="p">(</span>           <span class="c1">//      Branch:</span>
</span><span class='line'>                <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">),</span>      <span class="c1">//        Leaf: b</span>
</span><span class='line'>                <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">)),</span>     <span class="c1">//        Leaf: c</span>
</span><span class='line'>              <span class="n">leaf</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">)));</span>      <span class="c1">//      Leaf: d</span>
</span><span class='line'>
</span><span class='line'><span class="n">tree</span><span class="p">.</span><span class="n">Show</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Manual labeling</h2>

<p>First of all we need to know what labeling a tree means. In our case it means to navigate the tree and assign a integer label to every leaf. Tree navigation can usually be done in two ways, depth-first (<a href="http://en.wikipedia.org/wiki/Depth-first_search">DFS</a>) or breadth-first (<a href="http://en.wikipedia.org/wiki/Breadth-first_search">BFS</a>), we&#8217;ll use the former here. In order to store the label in the leaves we need to enrich its structure. We&#8217;ll do that by making the generic parameter of the tree a <code>Labeled&lt;T&gt;</code>, defined as follows.</p>

<figure class='code'><figcaption><span>Label  (labeled-class.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/labeled-class.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="kt">int</span> <span class="n">Label</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="nf">Labeled</span><span class="p">(</span><span class="kt">int</span> <span class="n">label</span><span class="p">,</span> <span class="n">T</span> <span class="k">value</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">Label</span> <span class="p">=</span> <span class="n">label</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="p">{</span> <span class="n">Label</span><span class="p">,</span> <span class="n">Value</span> <span class="p">}.</span><span class="n">ToString</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span> <span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">int</span> <span class="n">label</span><span class="p">,</span> <span class="n">T</span> <span class="k">value</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">label</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In practice, labeling a structure of type <code>Tree&lt;T&gt;</code> means transforming it into a <code>Tree&lt;Labeled&lt;T&gt;&gt;</code>. With this new knowledge labeling our tree manually is as simple as recreating the same tree structure and replacing the value of the leaves with a <code>Labeled&lt;string&gt;</code> instance, incrementing the value of the label manually every time we visit a leaf.<br/>
The value, or <em>state</em>, of the current label at each point in time lives in our brains: we&#8217;ll have to remember the previous value and increment it every time we visit a leaf. Not a big deal as long as the tree is small.</p>

<figure class='code'><figcaption><span>Manually labeled tree  (manually-labeled-tree.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/manually-labeled-tree.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>                                                 <span class="c1">// labeledTree.Show() outputs:</span>
</span><span class='line'><span class="kt">var</span> <span class="n">labeledTree</span> <span class="p">=</span> <span class="n">branch</span><span class="p">(</span>                        <span class="c1">// Branch:</span>
</span><span class='line'>                    <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">)),</span>       <span class="c1">//   Leaf: { Label = 0, Value = a }</span>
</span><span class='line'>                    <span class="n">branch</span><span class="p">(</span>                      <span class="c1">//   Branch:</span>
</span><span class='line'>                      <span class="n">branch</span><span class="p">(</span>                    <span class="c1">//     Branch:</span>
</span><span class='line'>                        <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">)),</span>   <span class="c1">//       Leaf: { Label = 1, Value = b }</span>
</span><span class='line'>                        <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">))),</span>  <span class="c1">//       Leaf: { Label = 2, Value = c }</span>
</span><span class='line'>                      <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">))));</span>   <span class="c1">//     Leaf: { Label = 3, Value = d }</span>
</span><span class='line'>
</span><span class='line'><span class="n">labeledTree</span><span class="p">.</span><span class="n">Show</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Functional labeling</h2>

<p>As you can see labeling a tree manually is not very useful, imagine to have a tree with more than a bunch branches and leaves, it becomes quickly inconvenient. What if we could label it programmatically? We indeed can, and we&#8217;ll have to come up with a function, which given our initial unlabeled <code>Tree&lt;T&gt;</code>, gives us back a <code>Tree&lt;Labeled&lt;T&gt;&gt;</code>.<br/>
Let&#8217;s call <code>Tree&lt;Labeled&lt;T&gt;&gt; Label&lt;T&gt;(Tree&lt;T&gt;)</code> such a function.</p>

<figure class='code'><figcaption><span>Label function  (label-function-empty.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/label-function-empty.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">Label</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// what to write here?</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a id="label"></a>
One constraint that we want to have is that we don&#8217;t want to store the current label in shared memory and update it whenever we visit a leaf. We would like to do it in a purely functional way. This means that the state needs to be passed around explicitly, with a starting value of 0. This suggests that we&#8217;ll need an additional support function that will thread the state via its arguments and return the updated state via its return value.<br/>
Given the structure of the data we&#8217;re handling this function will also most likely call itself recursively.</p>

<figure class='code'><figcaption><span>Label and Label1 functions  (functional-label.cs)</span> <a href='http://simoneb.github.com/downloads/code/monads/functional-label.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">Label</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">Label1</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">tree</span><span class="p">).</span><span class="n">Item2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">Labeled</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;&gt;</span> <span class="n">Label1</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">int</span> <span class="n">label</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">tree</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">tree</span> <span class="k">is</span> <span class="n">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">var</span> <span class="n">lf</span> <span class="p">=</span> <span class="n">tree</span> <span class="k">as</span> <span class="n">Leaf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">label</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">leaf</span><span class="p">(</span><span class="n">labeled</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">lf</span><span class="p">.</span><span class="n">Value</span><span class="p">)));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">var</span> <span class="n">br</span> <span class="p">=</span> <span class="n">tree</span> <span class="k">as</span> <span class="n">Branch</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">var</span> <span class="n">left</span> <span class="p">=</span> <span class="n">Label1</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">br</span><span class="p">.</span><span class="n">Left</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">var</span> <span class="n">right</span> <span class="p">=</span> <span class="n">Label1</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">Item1</span><span class="p">,</span> <span class="n">br</span><span class="p">.</span><span class="n">Right</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">right</span><span class="p">.</span><span class="n">Item1</span><span class="p">,</span> <span class="n">branch</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">Item2</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="n">Item2</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Label1</code> accepts an integer value representing the current label and a tree to be labeled. Its return value is a tuple containing the new label value and the labeled tree.</p>

<p>Let&#8217;s go through the code to see what it does exactly. You can see that it does two different things according to whether the tree to be labeled is a leaf or a branch.<br/>
In the first case it labels the leaf with the current value of the label, bumps it and returns a tuple containing the new label value and a leaf labeled with the value of the label before bumping it.<br/>
In the second case it first calls itself recursively to label the left branch of the tree, which returns again a tuple with the current label value and the labeled sub-tree. Then it does the same with the right branch by passing the just-returned label value as the current label value. Finally it returns a tuple containing the final state of the label and a newly constructed labeled branch containing the previously labeled left and right branches.<br/>
You might notice that it is this way of recursing that enables the depth-first approach.</p>

<p>Finally, <code>Label</code> calls <code>Label1</code> passing <code>0</code> as the initial state and returning only the second item in the tuple, which is the labeled tree.</p>

<p>The interesting thing about this approach is that it does not rely on any shared state to do the labeling. The current value of the label is passed as a function argument and the new value is returned as part of the result, versus storing the label value in a variable accessible from the function and incremented every time.</p>

<p>In the next post we&#8217;ll see how to make this state-passing less explicit, while still avoiding shared memory to store it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Async support in NUnit]]></title>
    <link href="http://simoneb.github.com/blog/2013/01/19/async-support-in-nunit/"/>
    <updated>2013-01-19T00:00:00+01:00</updated>
    <id>http://simoneb.github.com/blog/2013/01/19/async-support-in-nunit</id>
    <content type="html"><![CDATA[<p>.NET&rsquo;s version 5 of the C# compiler introduced support for an interesting feature related to multithreaded programming, available via the new <em>async</em> and <em>await</em> keywords.</p>

<p>This post is not much about the feature itself as plenty of information is available online, but rather the support that was introduced for it in NUnit. Here is a simple NUnit test:</p>

<p><figure class='code'><figcaption><span>A simple test  (nunit-simple-test.cs)</span> <a href='http://simoneb.github.com/downloads/code/nunit-simple-test.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="na">[Test]</span>
</span><span class='line'><span class="k">public</span> <span class="k">void</span> <span class="nf">OneSimpleTest</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">eightBall</span> <span class="p">=</span> <span class="k">new</span> <span class="n">EightBall</span><span class="p">();</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">answer</span> <span class="p">=</span> <span class="n">eightBall</span><span class="p">.</span><span class="n">ShouldIChangeJob</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">Is</span><span class="p">.</span><span class="n">True</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>So far so good, but let&rsquo;s assume that invoking that method on the 8 ball is really expensive in terms of execution time and you would like your production code invoking it to not just sit and wait until it completes.
That&rsquo;s where the async feature fits, and you could change the method to be an async, Task-returning one instead. How to make <em>that specific</em> method asynchronous is definitely out of scope here though.</p>

<h3>Testing asynchronous code</h3>

<p>In order to call the new method asynchronously the test code would need to be adapted as shown here:</p>

<p><figure class='code'><figcaption><span>A simple async test  (nunit-simple-async-test.cs)</span> <a href='http://simoneb.github.com/downloads/code/nunit-simple-async-test.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="na">[Test]</span>
</span><span class='line'><span class="k">public</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">OneSimpleTest</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">eightBall</span> <span class="p">=</span> <span class="k">new</span> <span class="n">EightBall</span><span class="p">();</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">answer</span> <span class="p">=</span> <span class="k">await</span> <span class="n">eightBall</span><span class="p">.</span><span class="n">ShouldIChangeJob</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">Is</span><span class="p">.</span><span class="n">True</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// why am I still here?</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Awaiting the result of the method implies that the test method has to be marked as async, too.
Now, assuming that you&rsquo;re not planning to change job you would really expect the test to fail, which it instead doesn&rsquo;t if run with a version of NUnit older than 2.6.2.</p>

<p>The reason behind this incorrect behavior is that asynchronous methods are rewritten by the C# compiler in a way that they return control to the caller as soon as they await on an operation which has not completed yet, as is the case with the invocation of the <em>ShouldIChangeJob</em> method. In this case therefore the control is returned to the code which called the <em>OneSimpleTest</em> method, which turns out to be NUnit itself.</p>

<p>Up to version 2.6.2 of NUnit the test runner always assumed that as soon as a test method returned then its execution was complete, and thus if no assertion failures were reported the test was successful.
This is no longer the case with asynchronous methods, as we just found out, because the now asynchronous test returns immediately after invoking <em>ShouldIChangeJob</em> on line 5.</p>

<p>Without any support from NUnit there was a simple fix available already, which was to <em>Wait</em> on the <em>Task</em> returned by the asynchronous method rather than <em>await</em> it.</p>

<p><figure class='code'><figcaption><span>A simple test - workaround for async  (nunit-simple-test-workaround.cs)</span> <a href='http://simoneb.github.com/downloads/code/nunit-simple-test-workaround.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="na">[Test]</span>
</span><span class='line'><span class="k">public</span> <span class="k">void</span> <span class="nf">OneSimpleTest</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">eightBall</span> <span class="p">=</span> <span class="k">new</span> <span class="n">EightBall</span><span class="p">();</span>
</span><span class='line'>    <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">answer</span> <span class="p">=</span> <span class="n">eightBall</span><span class="p">.</span><span class="n">ShouldIChangeJob</span><span class="p">();</span>
</span><span class='line'>    <span class="n">answer</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="n">answer</span><span class="p">.</span><span class="n">Result</span><span class="p">,</span> <span class="n">Is</span><span class="p">.</span><span class="n">True</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>This would work perfectly, although it&rsquo;s not as nice as being able to write the test code in the same way you would write the production code, that is, by using the await keyword. This has the additional disadvantage of exception handling behaving differently between await and Wait. When using await the code looks like everything is happening sequentially, and you can catch exceptions in the same way you do with sequential code. If <em>ShouldIChangeJob</em> threw an exception of the fictitious type <em>TimeoutException</em> you would see exactly that exception bubbling up from your code. When using Wait instead a <em>System.AggregateException</em> would bubble up, which is a sort of container for multiple exceptions which might have happened during an asynchronous operation, and would wrap the real <em>TimeoutException</em>. This of course makes await more intuitive and preferable over Wait.</p>

<h3>Just a matter of Waiting</h3>

<p>Introducing this support in NUnit doesn&rsquo;t necessarily mean that NUnit has now become asynchronous or that it allows to run tests in parallel. This is something which is being worked on for the next 3rd major release of NUnit though.</p>

<p>What we did in NUnit 2 was to allow users to write async tests without worrying about tests completing before their assertions were even evaluated, in addition to supporting thorough use of asynchronous methods in some specific framework use cases.
In other words, when invoking asynchronous test methods NUnit will &ldquo;sit and wait&rdquo; on your behalf, until the test method, along with all the asynchronous operations it invokes, has finally completed.</p>

<h3>Behind the scenes</h3>

<p>As should be clear by now NUnit&rsquo;s support for async methods is mainly a matter of detecting async methods, calling Wait on the Task returned by them and handling exceptions accordingly. This is true in most cases, although NUnit&rsquo;s need to be compatible with .NET 2.0 means that all of this logic needs to be implemented without referencing any .NET > 2.0 assemblies.</p>

<p>Yet this was still not as straightforward, but we really strived to open up as many intuitive usages of await/async as possible so to relieve the users from having to even think about it.</p>

<p>Although you might not have noticed it you&rsquo;ve already encountered one example of why this is not trivial. In the asynchronous sample above you can see that the test method is void.
What does it mean exactly? Well, it means that there is no Task on which to call Wait, and that really waiting for it to complete means setting up a new <em>SynchronizationContext</em> to hook into the .NET implementation of the async/await feature.</p>

<p>Although asynchronous void methods were not designed for this purpose and Microsoft itself discourages using them besides in event handlers, we really wanted to support them for a couple of reasons:</p>

<ol>
<li>Not supporting them would mean that NUnit would throw an exception at runtime every time a test is written with an async void signature</li>
<li>Most users would probably repeatedly commit the same mistake of writing asynchronous test methods as void async because no one really cares about their return value</li>
</ol>


<p>We thought that the two reasons above would lead to a frustrating user experience and decided to support async void tests as well as Task-returning ones. This choice came with some drawbacks too:</p>

<ol>
<li>The ways async void methods interact with the SynchronizationContext in which they run is undocumented and might change in the future, which opens up the possibility of breaking NUnit&rsquo;s implementation</li>
<li>Switching the SynchronizationContext in which the test method runs (the way NUnit supports async void tests, that is) might affect even up to a great extent the flow of the code wrapped by the new SynchronizationContext</li>
</ol>


<p>We though that these two issues alone did not justify the poor user experience and we opted to fully support async void tests.</p>

<h4>If not void, what?</h4>

<p>Now, although it seems quite reasonable to write the above asynchronous test as one returning void it is equally valid to write it so that it returns a Task instead.</p>

<p><figure class='code'><figcaption><span>A simple async test returning Task  (nunit-simple-async-task-test.cs)</span> <a href='http://simoneb.github.com/downloads/code/nunit-simple-async-task-test.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="na">[Test]</span>
</span><span class='line'><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">OneSimpleTest</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">eightBall</span> <span class="p">=</span> <span class="k">new</span> <span class="n">EightBall</span><span class="p">();</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">answer</span> <span class="p">=</span> <span class="k">await</span> <span class="n">eightBall</span><span class="p">.</span><span class="n">ShouldIChangeJob</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">Is</span><span class="p">.</span><span class="n">True</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>It is actually more advisable to do so if you are especially interested about forwards compatibility of your code for the reasons explained above. If you do this NUnit will not have to jump through hoops to run it correctly and will simply fall back to waiting on the returned task.</p>

<h3>async, where else</h3>

<p>As briefly mentioned earlier support for await/async in NUnit 2 goes beyond test methods. The good thing about it is that in most cases you won&rsquo;t have to think about whether it is supported or not, because it most likely is.</p>

<p>In any case here&rsquo;s a by-no-means complete overview of places where we had to do some relevant work.</p>

<h4>Test cases checking results via Task return values</h4>

<p>Methods marked with TestCaseAttribute can return values, which are then checked against the Result property of the test case. They now support returning result asynchronously:</p>

<p><figure class='code'><figcaption><span>An async test case returning Task&lt;int&gt;  (nunit-async-testcase.cs)</span> <a href='http://simoneb.github.com/downloads/code/nunit-async-testcase.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="na">[TestCase(1, 2, Result = 3)]</span>
</span><span class='line'><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">TestAddAsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">await</span> <span class="nf">SumAsync</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>	
</span><span class='line'>
</span><span class='line'><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SumAsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="k">return</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">+</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h4>Async lambdas</h4>

<p>The async support went slightly beyond test methods, and extended to framework features which accept lambda expression as their arguments:</p>

<p><figure class='code'><figcaption><span>Async lambda support in NUnit framework  (async-lambda-support.cs)</span> <a href='http://simoneb.github.com/downloads/code/async-lambda-support.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="na">[Test]</span>
</span><span class='line'><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">AsyncLambaSupport</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// throwing asynchronously</span>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">await</span> <span class="n">ThrowAsync</span><span class="p">(),</span> <span class="n">Throws</span><span class="p">.</span><span class="n">TypeOf</span><span class="p">&lt;</span><span class="n">InvalidOperationException</span><span class="p">&gt;());</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// returning values asynchronously</span>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">await</span> <span class="n">ReturnOneAsync</span><span class="p">(),</span> <span class="n">Is</span><span class="p">.</span><span class="n">EqualTo</span><span class="p">(</span><span class="m">1</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// &quot;After&quot; works with async methods too</span>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">await</span> <span class="n">ResutnOneAsync</span><span class="p">(),</span> <span class="n">Is</span><span class="p">.</span><span class="n">EqualTo</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">After</span><span class="p">(</span><span class="m">100</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Framework support is not yet available in NUnit 2.6.2, it will be in the next build.</p>

<h4>Test context availability</h4>

<p>If you don&rsquo;t know about <a href="http://nunit.org/index.php?p=testContext&amp;r=2.6.2">TestContext</a> I suggest you check it out as it might come handy in a bunch of scenarios. If you&rsquo;re already using it, just be aware that it is now accessible anywhere inside the body of asynchronous tests, which is how you would expect it to be.</p>

<h3>What else?</h3>

<p>This feature has been ported to the upcoming major release 3.0 of NUnit as well as to NUnitLite to make it available consistently throughout the whole testing platform.</p>

<p>If there&rsquo;s anything we&rsquo;ve missed feel free to let us know on the NUnit&rsquo;s <a href="http://groups.google.com/group/nunit-discuss">mailing list</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NUnit via LINQPad]]></title>
    <link href="http://simoneb.github.com/blog/2012/10/28/nunit-via-linqpad/"/>
    <updated>2012-10-28T00:00:00+02:00</updated>
    <id>http://simoneb.github.com/blog/2012/10/28/nunit-via-linqpad</id>
    <content type="html"><![CDATA[<p>I&#8217;ve been a frequent user of LINQPad for several years now for I enjoy the simplicity with which you can fire it up, start writing code and see the results immediately. I appreciate that other programming languages provide REPLs for you to try and even modify the currently running application, and I enjoy them when I have a chance to work with node.js or Ruby, but this is not something that people writing C# code are used to, and in any case outside the scope of this post.</p>
<p>Recently my involvement with NUnit has increased to some extent and on several occasions I found myself needing to try running one-off tests and quickly see their outcome in order to validate bug reports or in general for experimenting. <br />As you can guess this would usually require launching a full-featured IDE like Visual Studio, create a class library project, reference NUnit, build and run some NUnit runner against the resulting assembly. That&#8217;s a lot of work for just getting a few lines of code to run.</p>
<p>The idea was therefore to be able to run NUnit tests on LINQPad, which is definitely possible and quite simple, as it turns out.</p>
<p>Now, a bit of background about NUnit is in order. The current release, which at the time of this writing is 2.6.2 and has been available for a few days, along with the whole 2.x series, has always kept the framework and the core separate.</p>
<p>The framework is contained in the <em>nunit.framework.dll</em> assembly, which client code usually references in order to write tests. Just to mention a few it contains the TestAttribute and the Assert classes, which everyone writing unit tests should be familiar with.<br />The core, on the other hand, contains the code needed to run the tests, which includes test discovery, filtering, the logic for handling application domains and processes, and finally exposes this functionality by means of test runners. NUnit currently ships with a console and a graphical GUI runner.<br />This net separation of the core from the framework basically means that running tests in LINQPad via NUnit requires referencing both the core and the framework assemblies, and then invoking a runner pointing it at the current assembly. This is possible but also not the fastest and cleanest way to accomplish it.</p>
<p>Enter NUnitLite. <strong>NUnitLite </strong>has been around for some time now and the main difference with NUnit v2 that is of some relevance here is that there is no distinction between the core and the framework. Everything is contained within a single assembly that you can reference from your tests, and the very same project containing the tests can be used to run them with a single one-liner.</p>
<p>Although NUnitLite does not provide all of the features of NUnit it has quite enough of them for most needs, and above all simplifies our life a lot here.<br />On the other side, we&#8217;re going to leverage a new feature available in LINQPad, the ability to reference NuGet packages, which right now is provided in the beta version downloadable from <a href="http://www.linqpad.net/beta.aspx" title="LINQPad Beta">here</a>.&nbsp;</p>
<p>Now that the ground is set here are the steps to get started writing unit tests in LINQPad:</p>
<ol>
<li>Create a new query and set its Language to C# Program, which will create a stub main method</li>
<li>Add the NUnitLite NuGet package, which is easily done by hitting F4, then Add NuGet&#8230; and then looking up and selecting NUnitLite. Also add the namespaces NUnit.Framework and NUnitLite.Runner</li>
<li>Fill the main method with the single line which will allow to run the tests in the current assembly and finally start writing unit tests.<p /><figure class='code'><figcaption><span>NUnitLite in LINQPad  (linqpad-nunitlite.cs)</span> <a href='http://simoneb.github.com/downloads/code/linqpad-nunitlite.cs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">new</span> <span class="n">NUnitLite</span><span class="p">.</span><span class="n">Runner</span><span class="p">.</span><span class="n">TextUI</span><span class="p">().</span><span class="n">Execute</span><span class="p">(</span><span class="k">new</span><span class="p">[]{</span><span class="s">&quot;-noheader&quot;</span><span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Define other methods and classes here</span>
</span><span class='line'><span class="na">[Test]</span>
</span><span class='line'><span class="k">public</span> <span class="k">void</span> <span class="nf">SomeTest</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">Assert</span><span class="p">.</span><span class="n">Pass</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></li>
<li>Hit F5 and see the results of the test run</li>
</ol>
<p>The steps outlined above are quick and simple, but still require some time if you have to do it over and over, therefore a better option would be to save the raw template as a LINQPad query somewhere on your file system, or even better, although this chance is limited to the owners of a professional license, using a snippet which is available for download from the NUnit wiki <a href="http://www.nunit.org/wiki/doku.php?id=extras:nunit_via_linqpad" title="NUnit Wiki">here</a>.</p>
<p>The snippet takes care of the whole plumbing so you just need to download and copy it to the snippets folder, usually in <em>%userprofile%\Documents\LINQPad Snippets</em>, then just type the snippet shortcut,&nbsp;<strong>nunit</strong>, in any query window and you&#8217;re ready to write your tests.</p>
<ol> </ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Past, present and future of .NET assembly merging]]></title>
    <link href="http://simoneb.github.com/blog/2011/11/21/past-present-and-future-of-net-assembly-merging/"/>
    <updated>2011-11-21T00:00:00+01:00</updated>
    <id>http://simoneb.github.com/blog/2011/11/21/past-present-and-future-of-net-assembly-merging</id>
    <content type="html"><![CDATA[<p>Compiling code written for the .NET framework usually produces assemblies in the form of either standalone executables or libraries. These assemblies contain mainly Microsoft Intermediate Language (MSIL) code which is then jitted upon execution.</p>
<p>It&#8217;s not uncommon for libraries which expose public APIs to rely internally on assemblies provided by third parties that should not end up in the final package. I&#8217;ll take the mocking library NSubstitute as an example.</p>
<p>There are commonly a couple of reasons why they shouldn&#8217;t.&nbsp;First, the client code does not need to reference them directly as they are only used internally. Back to the mocking framework example, it wouldn&#8217;t make a lot of sense to build a dynamic proxy from scratch as there exist excellent implementations already, like Castle DynamicProxy, which NSubstitute uses.<br />The other reason is to avoid cluttering the release package of the library with dependencies that are of no interest to the end user, thus simplifying the distribution of the library which would then consist of a smaller number of files.</p>
<p>The aim is thus to&nbsp;embed&nbsp;somehow the dependent assemblies in a single assembly. There has been mainly a single approach to this so far, and it&#8217;s called ILMerge.</p>
<h3>ILMerge</h3>
<p><a href="http://research.microsoft.com/en-us/people/mbarnett/ilmerge.aspx">Mike Barnett&#8217;s ILMerge</a> is a free tool which statically links several assemblies into a single output assembly. It runs as a console application and rewrites the IL of the main assembly by embedding the contents of the other assemblies into it. It takes care of a couple of additional things, like strong naming and target framework version, but accepts additional configuration options which allow further customization. One particularly useful is <em>internalization</em> of types, which allows to change the accessibility levels of the types contained in the dependent assemblies, thus effectively hiding them to everyone except the containing assembly.</p>
<p>One thing to be aware of is that embedding types belonging to one assembly into another assembly makes the first lose its original identity. This can represent either a pro or a con depending on the use case. Serialization and security may not work correctly, as they usually make some use of metadata related to the assembly, which now no longer exists, but also opens up interesting scenarios.</p>
<p>NSubstitute <em>ILMerges</em>&nbsp;the Castle.Core.dll assembly, which contains the DynamicProxy part. If you were to use NSubstitute in a project where you needed to make use of DynamicProxy directly you would be safe, and could use whatever version of the library you liked, as the runtime would consider the types as belonging to different assemblies and thus not conflicting in any way. The only issue you could encounter is of conflicting namespaces if the assembly wasn&#8217;t merged with its types internalized. Public types would in fact still be visible and you would need to specify some alias to avoid ambiguous references.</p>
<p>If on the other hand NSubstitute didn&#8217;t merge Castle.Core.dll and distributed it alongside NSubstitute.dll, then you would be somewhat tied to use the version distributed with NSubstitute. Loading different versions of the same assembly in one AppDomain is in fact <a href="http://msdn.microsoft.com/en-us/library/dd153782.aspx#avoid_loading_multiple_versions">discouraged</a> as it can generate all sort of weird behaviors. Also it wouldn&#8217;t be very easy to load two versions of the same assembly because unless the assemblies resided in the GAC you would have to find a way to keep them both on the file system, and assuming you usually load assemblies from the same folder you couldn&#8217;t let two files with the same name stay in the same folder. In this case the version of the assembly ending up in the output folder would depend on the build process, according to the order it chose to resolve dependencies during compilation.</p>
<p>Another recent and blocking shortcoming of ILMerge has to do with WPF assemblies. These assemblies contain embedded resources which in turn encode the identities of the original containing assembly. As I said merged assemblies loose their identities, therefore these resources would no longer behave correctly. ILMerge would thereby need to extract the resources, patch the encoded assembly identities replacing them with the target assembly identity and re-encode them, something which it is not capable of doing as of now.</p>
<p>And that&#8217;s from embedded resources that comes another solution.</p>
<h3>Embedding assemblies as resources</h3>
<p>Serializing other files into assemblies as resources has always been possible. Resources can then be deserialized at runtime and manipulated. They can be anything, although commonly used for storing media, icons and inanimate data in general. Nothing prevents you from storing assemblies in there, and load them at runtime. This approach has been described thoroughly by Jeffrey Richter in his excellent CLR via C# book, whose relevant excerpt is available <a href="http://blogs.msdn.com/b/microsoft_press/archive/2010/02/03/jeffrey-richter-excerpt-2-from-clr-via-c-third-edition.aspx">here</a>.</p>
<p>The approach is simple, so simple that ILMerge creator commented:</p>
<blockquote class="posterous_short_quote">As the author of ILMerge, I think this is fantastic! If I had known about this, I never would have written ILMerge.</blockquote>
<p>The trick to make it work is to subscribe to the AppDomain&#8217;s AssemblyResolve event. This event is fired when the runtime is unable to locate a referenced assembly, and as a last chance gives the application developer a chance to pick it up according to custom logic. The logic here is to load the assembly from the resources and load it into the application domain.<br />One caveat is that the AssemblyResolve event needs to be subscribed to before any code requiring the embedded assemblies is ever run, which is not always possible. One such case is a .dll, which has not explicit entry point.</p>
<p>To work around that you have to rely on a feature of the .NET framework which is not exposed to the programming languages directly, called <a href="http://blogs.msdn.com/b/junfeng/archive/2005/11/19/494914.aspx">module initializers</a>. Think of type initializers (aka static constructors), just for modules. In the same way as type initializers are guaranteed to be called before any members in a type are accessed, modules initializers extend this guarantee to the types with an module (assemblies usually contain a single module).</p>
<p>Placing the AssemblyResolve subscription instructions in a module initializer is thereby either the safest or unique option to inject custom assembly resolution logic, but requires IL manipulation.</p>
<h3>Costura</h3>
<p><a href="http://code.google.com/p/costura/">Costura</a> is a neat open source project developed by Simon Cropp which takes care of all the steps described above, and is thereby the suggested way to merge third party assemblies using the embedded resource approach.</p>
<p>It does so by embedding all referenced assemblies marked as <em>copy local</em> (thus excluding assemblies living in the GAC, for instance) into the main assembly, and then injecting the module initializer code which subscribes to the AppDomain&#8217;s AssemblyResolve event and looks up unresolved assemblies from the embedded resources.</p>
<p>Costura only requires you to call its custom MSBuild task in the AfterBuild target of the main assembly project.</p>
<p><figure class='code'><figcaption><span>Costura task  (costura.xml)</span> <a href='http://simoneb.github.com/downloads/code/costura.xml'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;UsingTask</span>
</span><span class='line'>    <span class="na">TaskName=</span><span class="s">&quot;Costura.EmbedTask&quot;</span>
</span><span class='line'>    <span class="na">AssemblyFile=</span><span class="s">&quot;$(SolutionDir)[path to]\Costura.dll&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;Target</span> <span class="na">Name=</span><span class="s">&quot;AfterBuild&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;Costura.EmbedTask</span> <span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/Target&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>
<p>This approach however comes with its drawbacks too. Most notably it prevents multiple version of the same assembly to be loaded, as in this case the assemblies maintain their identity. This can be dangerous because it could lead to non-determinism in which version of one assembly is loaded. For example, if you distributed a library using this approach and the library client was referencing directly an assembly with the same identity as one of those embedded in your library, which assembly gets loaded in the application domain would depend on the order in which the client code uses your library. If your library is loaded in memory first, then its version of the third party assembly would be loaded in memory, in the other case the client code version of the library would be loaded instead, leading to a fully working application in the best case and to a runtime exception in the worst.</p>
<p>Both approaches have their pros and cons, but it&#8217;s useful to realize that both exist and know when to apply each.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Speaking's overrated]]></title>
    <link href="http://simoneb.github.com/blog/2011/11/19/speaking-s-overrated/"/>
    <updated>2011-11-19T00:00:00+01:00</updated>
    <id>http://simoneb.github.com/blog/2011/11/19/speaking-s-overrated</id>
    <content type="html"><![CDATA[<div style="margin: 8px;">
<p>Today is the&nbsp;<a href="http://agileday.it">Italian Agile Day</a>, happening in Rome.</p>
<p>I didn&#8217;t attend mostly because past editions haven&#8217;t been very interesting, with a few exceptions, and I&#8217;ve been following some sessions on the live streaming site from home.</p>
<p>It happens quite rarely that I hear anything really interesting being said at these meetings, but I can live with that, there&#8217;s usually not enough time to delve into a topic deep enough to provide any valuable understanding. More often, there is barely time to instigate curiosity so that people can further research when they go back home. This is perfectly healthy, and what I try to do when I speak myself.</p>
<p>Sadly what I see happening most of the times are speakers talking for hours without really saying anything except trying to sound convincing. I&#8217;ve experienced this so many times now that I&#8217;m starting to think that it is probably intentional attitude rather than a side effect due to lack of skill or anything else.&nbsp;<br />When I was younger I would look at these talks in wonder, asking myself when I would have been able to speak in the same way about complex topics that at the time I just could not understand. Now that I&#8217;ve somewhat grown up professionaly I can look at things a bit differently and judge with more awareness what is going on, and it pisses me off.&nbsp;<br />It does mostly because when you speak to people you have some responsibility towards your listeners, and they don&#8217;t expect you to deceive them or may not even be able to realize that it&#8217;s what you&#8217;re doing. There are other reasons, however.</p>
<p><strong>Out of context - deliberate omission</strong></p>
<p>You have probably heard someone saying that&nbsp;<em>context is king</em>. It indeed is. Many people tend to make absolute statements way too often, and to avoid the effort of figuring out whether there may be any truth in what they&#8217;re saying my current strategy is to simply assume that they are wrong.</p>
<blockquote>
<p style="text-align: left;"><em>Frameworks are a smell</em></p>
</blockquote>
<blockquote>
<p style="text-align: left;"><em>QA is useless</em></p>
</blockquote>
<p>These are just some examples of things I&#8217;ve heard presenters say in the recent past. Now I consider myself as being on neither side of the spectrum when it comes to these topics, because as usual&nbsp;<em>context is king</em>. How can you say that using an ORM is always wrong and slows you down? There are compromises that you need to be ready to accept, but aren&#8217;t always there?</p>
<p>Another variation of taking things out of context is when something is deliberately omitted. It is way too easy to support your thesis when you intentionally omit arguments that go against it. It&#8217;s not easy to realize omissions unless you know a topic very well, or you&#8217;re directly involved in the omission, like I had to hear right today about proposing (I proposed it) a supposedly terribly bad TDD video course to be watched by development teams in the company.</p>
<p><strong>Knowledge flaunt</strong></p>
<p>As I said it&#8217;s usually hard to delve into a topic enough during a time constrained speech. Nonetheless, it should not be an excuse to pretend you know much more about the topic than you actually do.<br />Once again it&#8217;s hard to judge whether someone is really an expert or is pretending to be one, and the most effective way is to know the person yourself. The most annoying attitude is when the speaker is presenting at the most of his knowledge while pretending that he&#8217;s talking about the easy things, and there&#8217;s much more to it that you&#8217;re not entitled to know just yet.</p>
<p>This happened very recently to me, with a person I know presenting&nbsp;<em>the easy things</em>&nbsp;about a topic and laughing annoyed at most people not getting it right. Just a week before me and him talking about the very same topic in a slightly more advanced manner caught him off guard, with me thinking whether he really knew anything about it.</p>
<p><strong>Fluff</strong></p>
<p>Lots of presenters finally just speak of fluff. In Italian it translates nicely to&nbsp;<em>fuffa</em>. This is probably the easier to figure out when attending a presentation, because at the end you are left thinking whether anything of what you&#8217;ve heard really made any sense.&nbsp;<br />Someone built their entire career on this, and you usually see them proposing training and courses. These people are dangerous mostly because they are attractive to companies. I personally believe that these people are not even worth a penny.</p>
<p><strong>Why speaking is overrated</strong></p>
<p>There is much more to this than I&#8217;ve been able to explain in my first blog post after several years, but I hope I have given some valid arguments.</p>
<p>I am under the impression that pretty much everything that you can hear talking about is overrated, as people have to make a living out of it.</p>
</div>
<p>&nbsp;</p>
]]></content>
  </entry>
  
</feed>
